<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xml:lang="en-us" lang="en-us">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="copyright" content="(C) Copyright 2005"/>
<meta name="DC.rights.owner" content="(C) Copyright 2005"/>
<meta name="DC.Type" content="reference"/>
<meta name="DC.Title" content="Toolkit streamsx.protobuf 1.0.0.0"/>
<meta name="DC.Format" content="XHTML"/>
<meta name="DC.Identifier" content="spldoc_toolkit"/>
<link rel="stylesheet" type="text/css" href="../../html/commonltr.css"/>
<link rel="stylesheet" type="text/css" href="../../html/spldoc.css"/>
<title>Toolkit streamsx.protobuf 1.0.0.0</title>
</head>
<body id="spldoc_toolkit">


<h1 class="title topictitle1 spltoolkitname">Toolkit <tt class="ph tt">streamsx.protobuf 1.0.0.0</tt></h1>

<div class="body refbody">
<div class="section">
<p class="p">
<a class="xref" href="../toolkits/toolkits.html">Toolkits</a> &gt; streamsx.protobuf 1.0.0.0</p>

</div>

<div class="section"><h2 class="title sectiontitle splhead-1">General Information</h2>


<p class="p">IBM Streams Protobuf Toolkit
</p>

<p class="p">The <tt class="ph tt">streamsx.protobuf</tt> toolkit contains operators for interacting with serialized protocol buffer messages. It contains two conversion operators and two simple source operators.
</p>

<p class="p">Currently, this toolkit only support <tt class="ph tt">proto2</tt> syntax.
</p>

<p class="p">Examples can be found in the <tt class="ph tt">streamsx.protobuf.samples</tt> directory.
</p>

</div>

<div class="section"><h2 class="title sectiontitle">Conversion operators
</h2>

<div class="p">
<ol class="ol">
<li class="li"> <tt class="ph tt">ProtobufParse</tt> takes a tuple with a <tt class="ph tt">blob</tt> field and emits a tuple matching the <tt class="ph tt">protoMessage</tt>    parameter type it is given.</li>

<li class="li">
<p class="p"> <tt class="ph tt">ProtobufBuild</tt> takes a tuple as generated by the <tt class="ph tt">spl-schema-from-protobuf</tt> script (see below)    and emits a serialized version in the Protobuf serialization format as a blob.
</p>
</li>

</ol>

</div>

</div>

<div class="section"><h2 class="title sectiontitle">Source operators
</h2>

<div class="p">
<ol class="ol">
<li class="li"> <tt class="ph tt">ProtobufTCPSource</tt> creates a TCP server that will accept connections which can pass 1 or    more Protobuf messages, each prefixed with a 4-byte record length.</li>

<li class="li">
<p class="p"> <tt class="ph tt">ProtobufFileSource</tt> reads binary files that contain Protobuf messages, each prefixed with    a 4-byte record length.
</p>
</li>

</ol>

</div>

</div>

<div class="section"><h2 class="title sectiontitle">Configuration
</h2>

<p class="p">The <tt class="ph tt">streamsx.protobuf</tt> toolkit requires the Protobuf libraries are installed on the compiling machine. Two environment variables are required: <tt class="ph tt">$STREAMSX_PROTOBUF_LIBPATH</tt> and <tt class="ph tt">$STREAMSX_PROTOBUF_INCLUDEPATH</tt>.
</p>

</div>

<div class="section"><h2 class="title sectiontitle">Generating schemas
</h2>

<p class="p">This toolkit contains a script under <tt class="ph tt">streamsx.protobuf/bin</tt> called <tt class="ph tt">spl-schema-from-protobuf</tt>. This script will generate tuples in SPL to match the Protobuf messages in .proto files. This is required to use the conversion operators. <tt class="ph tt">ProtobufParse</tt> must emit the tuple generated by the script corresponding to the Protobuf message it is receiving, and <tt class="ph tt">ProtobufBuild</tt> must receive the tuple generated by the script corresponding to the Protobuf message it is sending.
</p>

<p class="p">For all message and enum names, <tt class="ph tt">_pb</tt> is appended to the identifier. For all field names or enum values, <tt class="ph tt">_</tt> is appended to the identifier. An example can be seen in <tt class="ph tt">streamsx.protobuf.samples</tt>.
</p>

</div>

<div class="section"><h2 class="title sectiontitle">Usage
</h2>

<p class="p">To use this toolkit, create an empty application. Place your <tt class="ph tt">.proto</tt> file inside <tt class="ph tt">&lt;application&gt;/impl</tt>.
</p>

<p class="p">Call: <tt class="ph tt">&lt;path to streamsx.protobuf toolkit&gt;/bin/spl-schema-from-protobuf impl &lt;your protobuf file name&gt;</tt>
</p>

<p class="p">This will generate the SPL schema to use with the conversion operators. Next, you will invoke one of the operators within your composite. If you have a Protobuf message named <tt class="ph tt">my.package.MyMessage</tt>, then given the file:
</p>

<div class="p">
<pre class="pre codeblock">
// MyMessage.proto

syntax = "proto2";

package my.package;

message MyMessage {
    required string field = 1;
}
</pre>


</div>

<p class="p">The following SPL will be generated:
</p>

<div class="p">
<pre class="pre codeblock">
// my.package/MyMessage\_pb.spl

namespace my.package;

use my.package::*;

type MyMessage_pb = tuple&lt;
    rstring field_
&gt;;
</pre>


</div>

<p class="p"> ProtobufParse invocation
</p>

<p class="p">To use the ProtobufParse operator, it is invoked like this:
</p>

<div class="p">
<pre class="pre codeblock">
stream&lt;blob recordData&gt; serializedRecords = ProtobufFileSource() {
    param
        file: "&lt;binary file&gt;";
}

stream&lt;my.package::MyMessage_pb&gt; myMessages = ProtobufParse(serializedRecords) {
    param
        dataAttribute: recordData;
        protoMessage: "my.package.MyMessage";
        protoDirectory: "impl";
        protoRootFile: "MyMessage.proto";
}
</pre>


</div>

<p class="p"> ProtobufBuild invocation
</p>

<p class="p">To use the ProtobufBuild operator, it is invoked like this:
</p>

<div class="p">
<pre class="pre codeblock">
stream&lt;my.package::MyMessage_pb&gt; myMessages = Beacon() {
    param
        period: 1.0;
    output
        myMessages: field_ = "&lt;value&gt;";
}

stream&lt;blob recordData&gt; serializedRecords = ProtobufParse(myMessages) {
    param
        protoMessage: "my.package.MyMessage";
        protoDirectory: "impl";
        protoRootFile: "MyMessage.proto";
}
</pre>


</div>

</div>

<div class="section"><h2 class="title sectiontitle">Under the hood
</h2>

<p class="p">How do the converters work?
</p>

<p class="p">They utilize a grammar file in <tt class="ph tt">yapp</tt>, which is a Perl port of <tt class="ph tt">yacc</tt>. The grammar defines the <tt class="ph tt">proto2</tt> syntax according to the Google language specification sheet. The <tt class="ph tt">yapp</tt> grammar is compiled into a Perl module, which generates a parse tree containing all message and enum definitions within the file. For each import from the root file, this process is repeated until all files have been processed.
</p>

<p class="p">The Build/Parse operators iterate through this parse tree to map Protobuf message values into and out of Streams tuples. At compile time, these operators run this parser to create the tree, and then they run the <tt class="ph tt">protoc</tt> command to generate the C++ that is the messages will use. The C++ is compiled into a shared object library named <tt class="ph tt">libcustomproto.so</tt>, which is stored in the application directory's <tt class="ph tt">impl/lib</tt>. This means that if more than one Build and/or Parse operator exists in the same composite, they cannot be compiled in parallel and they must used the same Protobuf definitions. Otherwise, race conditions will occur and one or both will be non-functional at run time.
</p>

<p class="p">Variable mapping is generated recursively, so infinitely complex messages can be handled. There are two limitations: These operators cannot handle <tt class="ph tt">group</tt> fields or <tt class="ph tt">oneof</tt> fields. Oneof fields are planned for future implementation, but group fields have been deprecated by Google in favor of nested messages.
</p>

<p class="p">Every available effort to ensure the readability of the generated code was made, as this makes debugging issues much easier. Feel free to take a look. However, all variable names are randomly generated to reduce the likelihood of a name collision. Name collisions are not checked beforehand, as the likelihood of not having a name collision in a message with 100 fields is (1-1/52^20)^100, which is infintessimally small.
</p>

<p class="p">Some older versions of the <tt class="ph tt">protoc</tt> compiler do not require the first line to state <tt class="ph tt">syntax = "proto2";</tt>, but this parser requires the statement to be present regardless of the version of <tt class="ph tt">protoc</tt> installed.
</p>

<dl class="dl">
  
  <dt class="dt dlterm">Version</dt>

  <dd class="dd">1.0.0.0</dd>

  
  
  <dt class="dt dlterm">Required Product Version</dt>

  <dd class="dd">4.0.0.0</dd>

  
  
  <dt class="dt dlterm">Author</dt>

  <dd class="dd">IBMStreams</dd>

  
</dl>

</div>

<div class="section"><h2 class="title sectiontitle splhead-1">Indexes</h2>
  
  <dl class="dl">
    <dt class="dt dlterm"/>
<dd class="dd"/>

    <dt class="dt dlterm"><a class="xref" href="ix$Namespace.html">Namespaces</a></dt>
<dd class="dd"/>

    <dt class="dt dlterm"><a class="xref" href="ix$Operator.html">Operators</a></dt>
<dd class="dd"/>

  </dl>

</div>

<div class="section"><h2 class="title sectiontitle splhead-1">Namespaces</h2>
  
  <dl class="dl">
    
      <dt class="dt dlterm splpart"><a class="xref" href="ns$streamsx.protobuf.html">streamsx.protobuf</a></dt>

      <dd class="dd"/>

      <dd class="dd"><dl class="dl">
        <dt class="dt dlterm">Operators</dt>

        <dd class="dd">
<ul class="sl simple">
<li class="sli"><a class="xref" href="op$streamsx.protobuf$ProtobufBuild.html">ProtobufBuild</a></li>

<li class="sli"><a class="xref" href="op$streamsx.protobuf$ProtobufFileSource.html">ProtobufFileSource</a></li>

<li class="sli"><a class="xref" href="op$streamsx.protobuf$ProtobufParse.html">ProtobufParse</a></li>

<li class="sli"><a class="xref" href="op$streamsx.protobuf$ProtobufTCPSource.html">ProtobufTCPSource</a></li>

</ul>

        </dd>

      </dl>
</dd>

       </dl>

</div>

</div>


</body>
</html>